#ifndef TEXT_OVERLAY_H
#define TEXT_OVERLAY_H

#include <vector>
#include <string>
#include <Eigen/Core>

// Simple 5x7 font
// 0x00 is space
// Each byte represents a column, 5 bytes per char.
// We will use a simplified font for A-Z, a-z, 0-9, space, and some punctuation.
// For brevity, I'll implement a very minimal set or a procedural way if possible, 
// but a bitmap is best.

// 5x7 font data for ASCII 32-127
// 5 bytes per character
static const unsigned char font5x7[] = {
    0x00, 0x00, 0x00, 0x00, 0x00, // space
    0x00, 0x00, 0x5F, 0x00, 0x00, // !
    0x00, 0x07, 0x00, 0x07, 0x00, // "
    0x14, 0x7F, 0x14, 0x7F, 0x14, // #
    0x24, 0x2A, 0x7F, 0x2A, 0x12, // $
    0x23, 0x13, 0x08, 0x64, 0x62, // %
    0x36, 0x49, 0x55, 0x22, 0x50, // &
    0x00, 0x05, 0x03, 0x00, 0x00, // '
    0x00, 0x1C, 0x22, 0x41, 0x00, // (
    0x00, 0x41, 0x22, 0x1C, 0x00, // )
    0x14, 0x08, 0x3E, 0x08, 0x14, // *
    0x08, 0x08, 0x3E, 0x08, 0x08, // +
    0x00, 0x50, 0x30, 0x00, 0x00, // ,
    0x08, 0x08, 0x08, 0x08, 0x08, // -
    0x00, 0x60, 0x60, 0x00, 0x00, // .
    0x20, 0x10, 0x08, 0x04, 0x02, // /
    0x3E, 0x51, 0x49, 0x45, 0x3E, // 0
    0x00, 0x42, 0x7F, 0x40, 0x00, // 1
    0x42, 0x61, 0x51, 0x49, 0x46, // 2
    0x21, 0x41, 0x45, 0x4B, 0x31, // 3
    0x18, 0x14, 0x12, 0x7F, 0x10, // 4
    0x27, 0x45, 0x45, 0x45, 0x39, // 5
    0x3C, 0x4A, 0x49, 0x49, 0x30, // 6
    0x01, 0x71, 0x09, 0x05, 0x03, // 7
    0x36, 0x49, 0x49, 0x49, 0x36, // 8
    0x06, 0x49, 0x49, 0x29, 0x1E, // 9
    0x00, 0x36, 0x36, 0x00, 0x00, // :
    0x00, 0x56, 0x36, 0x00, 0x00, // ;
    0x08, 0x14, 0x22, 0x41, 0x00, // <
    0x14, 0x14, 0x14, 0x14, 0x14, // =
    0x00, 0x41, 0x22, 0x14, 0x08, // >
    0x02, 0x01, 0x51, 0x09, 0x06, // ?
    0x32, 0x49, 0x79, 0x41, 0x3E, // @
    0x7E, 0x11, 0x11, 0x11, 0x7E, // A
    0x7F, 0x49, 0x49, 0x49, 0x36, // B
    0x3E, 0x41, 0x41, 0x41, 0x22, // C
    0x7F, 0x41, 0x41, 0x22, 0x1C, // D
    0x7F, 0x49, 0x49, 0x49, 0x41, // E
    0x7F, 0x09, 0x09, 0x09, 0x01, // F
    0x3E, 0x41, 0x49, 0x49, 0x7A, // G
    0x7F, 0x08, 0x08, 0x08, 0x7F, // H
    0x00, 0x41, 0x7F, 0x41, 0x00, // I
    0x20, 0x40, 0x41, 0x3F, 0x01, // J
    0x7F, 0x08, 0x14, 0x22, 0x41, // K
    0x7F, 0x40, 0x40, 0x40, 0x40, // L
    0x7F, 0x02, 0x0C, 0x02, 0x7F, // M
    0x7F, 0x04, 0x08, 0x10, 0x7F, // N
    0x3E, 0x41, 0x41, 0x41, 0x3E, // O
    0x7F, 0x09, 0x09, 0x09, 0x06, // P
    0x3E, 0x41, 0x51, 0x21, 0x5E, // Q
    0x7F, 0x09, 0x19, 0x29, 0x46, // R
    0x46, 0x49, 0x49, 0x49, 0x31, // S
    0x01, 0x01, 0x7F, 0x01, 0x01, // T
    0x3F, 0x40, 0x40, 0x40, 0x3F, // U
    0x1F, 0x20, 0x40, 0x20, 0x1F, // V
    0x3F, 0x40, 0x38, 0x40, 0x3F, // W
    0x63, 0x14, 0x08, 0x14, 0x63, // X
    0x07, 0x08, 0x70, 0x08, 0x07, // Y
    0x61, 0x51, 0x49, 0x45, 0x43, // Z
    0x00, 0x7F, 0x41, 0x41, 0x00, // [
    0x02, 0x04, 0x08, 0x10, 0x20, // \ (backslash)
    0x00, 0x41, 0x41, 0x7F, 0x00, // ]
    0x04, 0x02, 0x01, 0x02, 0x04, // ^
    0x40, 0x40, 0x40, 0x40, 0x40, // _
    0x00, 0x01, 0x02, 0x04, 0x00, // `
    0x20, 0x54, 0x54, 0x54, 0x78, // a
    0x7F, 0x48, 0x44, 0x44, 0x38, // b
    0x38, 0x44, 0x44, 0x44, 0x20, // c
    0x38, 0x44, 0x44, 0x48, 0x7F, // d
    0x38, 0x54, 0x54, 0x54, 0x18, // e
    0x08, 0x7E, 0x09, 0x01, 0x02, // f
    0x0C, 0x52, 0x52, 0x52, 0x3E, // g
    0x7F, 0x08, 0x04, 0x04, 0x78, // h
    0x00, 0x44, 0x7D, 0x40, 0x00, // i
    0x20, 0x40, 0x44, 0x3D, 0x00, // j
    0x7F, 0x10, 0x28, 0x44, 0x00, // k
    0x00, 0x41, 0x7F, 0x40, 0x00, // l
    0x7C, 0x04, 0x18, 0x04, 0x78, // m
    0x7C, 0x08, 0x04, 0x04, 0x78, // n
    0x38, 0x44, 0x44, 0x44, 0x38, // o
    0x7C, 0x14, 0x14, 0x14, 0x08, // p
    0x08, 0x14, 0x14, 0x18, 0x7C, // q
    0x7C, 0x08, 0x04, 0x04, 0x08, // r
    0x48, 0x54, 0x54, 0x54, 0x20, // s
    0x04, 0x3F, 0x44, 0x40, 0x20, // t
    0x3C, 0x40, 0x40, 0x20, 0x7C, // u
    0x1C, 0x20, 0x40, 0x20, 0x1C, // v
    0x3C, 0x40, 0x30, 0x40, 0x3C, // w
    0x44, 0x28, 0x10, 0x28, 0x44, // x
    0x0C, 0x50, 0x50, 0x50, 0x3C, // y
    0x44, 0x64, 0x54, 0x4C, 0x44, // z
    0x00, 0x08, 0x36, 0x41, 0x00, // {
    0x00, 0x00, 0x7F, 0x00, 0x00, // |
    0x00, 0x41, 0x36, 0x08, 0x00, // }
    0x10, 0x08, 0x08, 0x10, 0x08  // ~
};

inline void draw_char(std::vector<unsigned char> &rgb_image, int width, int height, char c, int x, int y, const Eigen::Vector3d &color) {
    if (c < 32 || c > 126) c = 32;
    int index = (c - 32) * 5;
    for (int col = 0; col < 5; ++col) {
        unsigned char line = font5x7[index + col];
        for (int row = 0; row < 7; ++row) {
            if ((line >> row) & 1) {
                int px = x + col;
                int py = y + row;
                if (px >= 0 && px < width && py >= 0 && py < height) {
                    // Flip y because image origin is usually top-left or bottom-left depending on convention.
                    // In this assignment, viewing_ray uses i from 0 to height-1.
                    // Usually i=0 is top.
                    // Let's assume i=0 is top.
                    // But wait, viewing_ray usually maps i to v coordinate.
                    // If i=0 is top, then y=0 is top.
                    // Let's just draw directly to rgb_image index.
                    // rgb_image is 1D array.
                    // index = 3 * (px + width * py)
                    int idx = 3 * (px + width * py);
                    rgb_image[idx + 0] = (unsigned char)(std::min(color[0], 1.0) * 255);
                    rgb_image[idx + 1] = (unsigned char)(std::min(color[1], 1.0) * 255);
                    rgb_image[idx + 2] = (unsigned char)(std::min(color[2], 1.0) * 255);
                }
            }
        }
    }
}

inline void draw_text(std::vector<unsigned char> &rgb_image, int width, int height, const std::string &text, int x, int y, const Eigen::Vector3d &color, int scale = 1) {
    int cursor_x = x;
    for (char c : text) {
        for (int s_x = 0; s_x < scale; ++s_x) {
            for (int s_y = 0; s_y < scale; ++s_y) {
                 // This is inefficient scaling, but simple.
                 // Actually, better to scale inside draw_char or just draw multiple pixels.
            }
        }
        // Simple scaling: just draw at larger intervals? No, that makes it sparse.
        // Let's just stick to scale=1 for now or implement pixel replication.
        
        // Pixel replication for scale
        if (c < 32 || c > 126) c = 32;
        int index = (c - 32) * 5;
        for (int col = 0; col < 5; ++col) {
            unsigned char line = font5x7[index + col];
            for (int row = 0; row < 7; ++row) {
                if ((line >> row) & 1) {
                    for (int sx = 0; sx < scale; ++sx) {
                        for (int sy = 0; sy < scale; ++sy) {
                            int px = cursor_x + col * scale + sx;
                            int py = y + row * scale + sy;
                            if (px >= 0 && px < width && py >= 0 && py < height) {
                                int idx = 3 * (px + width * py);
                                rgb_image[idx + 0] = (unsigned char)(std::min(color[0], 1.0) * 255);
                                rgb_image[idx + 1] = (unsigned char)(std::min(color[1], 1.0) * 255);
                                rgb_image[idx + 2] = (unsigned char)(std::min(color[2], 1.0) * 255);
                            }
                        }
                    }
                }
            }
        }
        cursor_x += 6 * scale; // 5 width + 1 spacing
    }
}

#endif
